# 作業ログ: 回転軸ドリフト問題の修正

## プロンプト
ここでrotationAxisを渡してしまうと、RotationSystemでは対象Entityに対して、どんどん相対的に傾いた回転を加えてしまうので、ここではy軸方向のベクトルを渡してください

また、cubeEntityをaddChildする前に、予めy軸から30°傾けた回転行列を作って設定してください

## 概要
RotationSystemにおける回転軸ドリフト問題を修正しました。相対的な回転の累積により軸が徐々にずれていく問題に対し、初期回転をエンティティの姿勢として設定し、自転はy軸方向の絶対回転として適用する方式に変更しました。

## 問題の詳細
### 発生していた問題
- RotationComponentに傾いた回転軸（例: `[sin(30°), cos(30°), 0]`）を設定
- RotationSystemが毎フレーム、エンティティの現在の姿勢に対して相対的に回転を適用
- 結果として回転軸が徐々にドリフト（ずれる）

### 原因
RotationSystemの実装（`RotationSystem.swift:19-20`）:
```swift
let rotation = simd_quatf(angle: angularSpeed, axis: rotationComponent.axis)
entity.orientation = rotation * entity.orientation
```
この実装では、`rotationComponent.axis`は常にワールド座標系での軸を表すが、エンティティが既に回転している場合、その軸方向も累積的に変化してしまう。

## 変更点

### ImmersiveView.swift (39-51行)

#### Before
```swift
// 半径1mの位置に配置（X軸方向）
cubeEntity.transform.translation = SIMD3<Float>(1, 0, 0)

// OrbitComponentを追加（半径1m、周期10秒、Y軸まわり）
cubeEntity.components.set(OrbitComponent(radius: 1.0, period: 10.0, axis: [0, 1, 0]))

// RotationComponentを追加（垂直方向から30°傾けた軸で自転、周期5秒）
// 垂直方向（Y軸）から30°傾けた軸を計算
let tiltAngle = Float(30.0 * .pi / 180.0) // 30度をラジアンに変換
let rotationAxis = SIMD3<Float>(sin(tiltAngle), cos(tiltAngle), 0)
cubeEntity.components.set(RotationComponent(axis: rotationAxis, period: 5.0))

origin.addChild(cubeEntity)
```

#### After
```swift
// y軸から30°傾けた回転を設定
let tiltAngle = Float(30.0 * .pi / 180.0)
let tiltRotation = simd_quatf(angle: tiltAngle, axis: SIMD3<Float>(1, 0, 0))
cubeEntity.transform.rotation = tiltRotation

// OrbitComponentを追加（半径3m、周期5秒、Y軸まわり）
cubeEntity.components.set(OrbitComponent(radius: 3.0, period: 5.0, axis: [0, 1, 0]))

// RotationComponentを追加（y軸方向で自転、周期1秒）
cubeEntity.components.set(RotationComponent(axis: [0, 1, 0], period: 1.0))

origin.addChild(cubeEntity)
```

#### 変更内容
1. **初期姿勢の設定**:
   - `cubeEntity.transform.rotation`にx軸周りに30°傾けた回転クォータニオンを設定
   - エンティティの初期姿勢として傾きを表現

2. **RotationComponentの軸**:
   - 傾いた軸 `[sin(30°), cos(30°), 0]` → y軸 `[0, 1, 0]`に変更
   - RotationSystemで絶対的な回転として適用

3. **パラメータ調整** (ユーザーによる変更):
   - 軌道半径: 1m → 3m
   - 軌道周期: 10秒 → 5秒
   - 自転周期: 5秒 → 1秒

## 技術的な解説

### アプローチの違い

#### 旧アプローチ（問題あり）
- 傾いた回転軸をComponentに保存
- 毎フレーム、その軸周りに相対回転を適用
- 軸がローカル座標系で解釈されるため、累積的にドリフト

#### 新アプローチ（修正版）
- 傾きは初期姿勢（`transform.rotation`）として表現
- 自転はy軸周りの絶対回転として適用
- RotationSystemは常にy軸周りに回転するため、軸のドリフトが発生しない

### クォータニオンと回転の合成
```swift
// 初期姿勢: x軸周りに30°傾ける
let tiltRotation = simd_quatf(angle: tiltAngle, axis: SIMD3<Float>(1, 0, 0))

// 自転: y軸周りの回転（RotationSystemが毎フレーム適用）
let spinRotation = simd_quatf(angle: angularSpeed, axis: [0, 1, 0])
```

RotationSystemでは以下のように合成（`RotationSystem.swift:20`）:
```swift
entity.orientation = rotation * entity.orientation
```

これにより、エンティティはローカルy軸周りに回転し、初期姿勢の傾きを維持します。

## 副作用
なし。既存の円周運動（OrbitComponent）は影響を受けず、回転軸のドリフト問題のみが修正されました。

## 関連ファイル
- `/Users/taat/git/SolarSystemClaudeCode/SolarSystemClaudeCode/ImmersiveView.swift` (修正)
- `/Users/taat/git/SolarSystemClaudeCode/SolarSystemClaudeCode/RotationComponent.swift` (参照)
- `/Users/taat/git/SolarSystemClaudeCode/SolarSystemClaudeCode/RotationSystem.swift` (参照)

## コーディングガイドライン準拠
- ✅ ECS (Entity Component System) パターンを使用
- ✅ 初期姿勢と動的回転を明確に分離
- ✅ 絶対的な回転軸を使用して累積誤差を防止
